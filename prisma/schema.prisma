datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserLevel {
  NOVICE
  EXPERIENCED
  EXPERT
}

model User {
  id               Int        @id @default(autoincrement())
  name             String?
  email            String     @unique
  password         String
  role             String
  points           Int?
  phoneNumber      String?
  city             String?
  country          String?
  registrationDate DateTime   @default(now())
  isCompanyVerified Boolean   @default(false)
  level            UserLevel  @default(NOVICE)
  company          Company?   // Связь с моделью Company, без аргументов fields и references
  companyId        Int?
  listings         Listing[]
  responses        Response[]
  pointsSpent      PointsSpent[]
  pointsAdded      PointsAdded[]
  employees        CompanyEmployee[] // Связь с компанией через сотрудников
  relatedModels RelatedModel[] // Добавьте это поле для обратной связи
  reviews          Review[]   // Это связь с моделью Review
  pointTransfers   PointTransfer[]   // Обратная связь с моделью PointTransfer
  

}

model Company {
  id                    Int                          @id @default(autoincrement())
  name                  String
  binOrIin              String
  region                String
  contacts              String?
  director              String
  rating                Float?
  balance               Int                          @default(1000) // Баланс компании для управления баллами
  owner                 User                         @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId               Int                          @unique // Уникальный владелец компании
  employees             CompanyEmployee[]            // Связь с сотрудниками компании
  reviews               Review[]                     // Связь с отзывами компании
  pointTransfers        PointTransfer[]              // Связь с переводами баллов
  balanceTransactions   CompanyBalanceTransaction[]  // Обратная связь с историей транзакций
  moderationStatus      ModerationStatus             @default(PENDING) // Статус модерации компании
  description           String?                      // Описание компании
  website               String?                      // Сайт компании
  workingHours          String?                      // График работы
  address               String?                      // Адрес компании
}


enum ModerationStatus {
  PENDING   // На модерации
  APPROVED  // Одобрено
  REJECTED  // Отклонено
}

// Включаем перечисление для типов транзакций
enum TransactionType {
  REPLENISHMENT  // Пополнение
  DEBIT          // Списание
}

model CompanyBalanceTransaction {
  id               Int             @id @default(autoincrement())
  company          Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId        Int
  amount           Int             // Количество добавленных или вычтенных баллов (положительное — пополнение, отрицательное — списание)
  transactionType  TransactionType // Ссылаемся на перечисление
  description      String?         // Описание операции (например, причина пополнения)
  adminId          Int?            // Идентификатор администратора, выполнившего операцию
  transactionDate  DateTime        @default(now()) // Дата и время операции
}


model PointTransfer {
  id             Int       @id @default(autoincrement())
  company        Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId      Int       // Идентификатор компании, которая выполняет перевод
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         Int       // Идентификатор пользователя, который получает баллы
  points         Int       // Количество баллов, переданных пользователю
  transferDate   DateTime  @default(now()) // Дата и время перевода
  description    String?   // Описание перевода (например, "Бонус за выполнение задачи")
}


model Review {
  id           Int      @id @default(autoincrement())
  company      Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId    Int
  reviewer     User     @relation(fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewerId   Int
  rating       Int      // Рейтинг (например, от 1 до 5)
  comment      String?  // Текстовый отзыв, если есть
  createdAt    DateTime @default(now())
  isModerated  Boolean  @default(false) // Флаг для модерации отзыва
  
}




model CompanyEmployee {
  id          Int       @id @default(autoincrement())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade) // Добавляем onDelete: Cascade
  userId      Int
  company     Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId   Int
  role        String    // Роль сотрудника (например, "менеджер", "директор отдела продаж")
  joinedAt    DateTime  @default(now()) // Дата присоединения к компании
}

model PointsAdded {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade) // Добавляем onDelete: Cascade
  userId     Int
  points     Int      // Количество добавленных баллов
  addedAt    DateTime @default(now()) // Дата и время пополнения
  addedBy    String?  // Идентификатор администратора, который добавил баллы
  reason     String?  // Причина пополнения
  priceAtAdded Int?   // Стоимость балла на момент пополнения
}


model PointsSpent {
  id          Int      @id @default(autoincrement())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade) // Добавляем onDelete: Cascade
  userId      Int
  response    Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  responseId  Int
  listing     Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId   Int
  pointsUsed  Int      // Количество потраченных баллов
  spentAt     DateTime @default(now()) // Дата и время расхода баллов
}


model PointsPrice {
  id         Int      @id @default(autoincrement())
  price      Int      // Стоимость одного балла
  validFrom  DateTime @default(now())
  validUntil DateTime?
  history    PointPriceHistory[] @relation("PriceHistory")
}

model PointPriceHistory {
  id           Int      @id @default(autoincrement())
  pointsPrice  PointsPrice @relation("PriceHistory", fields: [pointsPriceId], references: [id], onDelete: Cascade)
  pointsPriceId Int
  oldPrice     Int      // Старая цена балла
  newPrice     Int      // Новая цена балла
  changedAt    DateTime @default(now())
  changedBy    String   // Кто изменил цену
}

model PointsStatistics {
  id               Int      @id @default(autoincrement())
  period           String   // Период статистики
  totalPointsAdded Int      // Общая сумма начисленных баллов за период
  totalPointsSpent Int      // Общая сумма потраченных баллов за период
  statisticsDate   DateTime @default(now())
}

model Listing {
  id             Int       @id @default(autoincrement())
  title          String
  content        String
  published      Boolean   @default(false)
  deliveryDate   DateTime  @default(now())
  publishedAt    DateTime  @default(now())
  expirationDate DateTime?
  purchaseDate   DateTime?
  author         User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId       Int
  responses      Response[] 
  category       Category? @relation(fields: [categoryId], references: [id])
  categoryId     Int
  responseCost   Int       @default(10)
  pointsSpent    PointsSpent[]
  purchaseMethod   String?   // Метод закупки, например, "понижение цены", "запрос ценового предложения"
  paymentTerms     String?   // Условия оплаты (новое поле)
  type          String   // Новый тип объявления: товар или услуга
}

model Response {
  id          Int      @id @default(autoincrement())
  responder   User     @relation(fields: [responderId], references: [id], onDelete: Cascade) // Добавляем onDelete: Cascade
  responderId Int
  message     String?
  listing     Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId   Int
  status      String   @default("pending")
  createdAt   DateTime @default(now())
  accepted    Boolean?
  pointsSpent PointsSpent[]
}

model Category {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  listings Listing[]
}

model RelatedModel {
  id        Int    @id @default(autoincrement())
  ownerId   Int?
  owner     User?  @relation(fields: [ownerId], references: [id], onDelete: Cascade)
}

